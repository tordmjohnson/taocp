#!/bin/bash

# constants.sh
#
# Generate a Tex file presenting a table of constants in hexadecimal format to 36
# places. The output could be processed by a tool such as pdflatex to produce a
# corresponding PDF file as:
# 
#    constants.sh > constants.tex && pdflatex -interaction=errorstopmode constants.tex
# 
# Required scripts include:
# 
#    apery.bc             A bc script required to compute Apery's constant.
#    eulermascheroni.bc   A bc script required to compute the Euler-Mascheroni constant.
#    gamma.bc             A bc script required to compute the Gamma function.
#    zetaderivative2.bc   A bc script required to compute Riemann-Zeta derivative at 2.
# 
# If running pdflatex on a Tex file named constants.tex, the following files will be generated:
# 
#    constants.aux   Auxiliary output file.
#    constants.log   Log file.
#    constants.pdf   PDF output.
# 
# The errata for Volume 1 of Knuth's The Art of Computer Programming, available at:
# 
#    http://www-cs-faculty.stanford.edu/~uno/all1.ps.gz
# 
# On page 47, a note for "Page 620 Table 2," dated May 6, 1999, explains:
# 
#    In the next edition I plan to give these constants to 36 hexadecimal places,
#    instead of 45 octal places.
# 
# The Tex file generated by this script attempts to do just that.
# 
# tmj   2012.12.20   Created.   [tord.m.johnson@gmail.com]

# get_constant(e, b, d, g)
#
# Function to obtain a string representation of a constant number.
# 
#    e   The (decimal) expression to evaluate.
#    b   The desired number base.
#    d   The desired number of (fractional) digits.
#    g   The number of digits per group.
# 
# Returns a string of the number e in base b with d significant fractional digits arranged into groups of g digits each.

get_constant() {

   local -r    expression=$1                             # input expression (base 10)
   local -r -i base=$2                                   # output base
   local -r -i digits=$3                                 # output number of fractional digits
   local -r -i group=$4                                  # number of digits per group
   local -r -i scale=2*${digits}+${group}                # scale for bc (digits + 1)
   local -r -i length=2*${scale}                         # line length
   local -r -i extragroups=(${scale}-${digits})/${group} # number of extraneous groups

   local    number            # number (both integer and fractional parts)
   local    sign              # sign
   local    integer           # integer part
   local    fractional        # fractional part
   local -a fractional_groups # fractional part groups
   local -i rounding_digit    # last fractional digit for rounding
   local    rounding_sign     # "+" or "-" depending on last fractional digit
   local -i index             # general index

   number=`echo "scale=${scale}; obase=${base}; ${expression}" | BC_LINE_LENGTH=${length} bc -l`

   integer=${number%%\.*}
   if [ ${#integer} -eq 0 ]; then
      integer="0"
   fi

   # ensure fractional of length ${scale}

   fractional=${number#*\.}
   fractional=${fractional:0:${scale}}
   while [ ${#fractional} -lt ${scale} ]
      do
         fractional="${fractional}0"
      done

   fractional_groups=(`echo "${fractional}" | fold -w ${group}`)

   # We over-approximated by ${extragroups} groups;
   # drop least significant digits to determine rounding.

   index=${#fractional_groups[*]}-${extragroups};

   rounding_digit=${fractional_groups[${index}]:0:1}

   if [ ${rounding_digit} -lt `expr ${base} / 2` ]; then
      rounding_sign="+"
   else
      index=${index}-1
      fractional_groups[${index}]=`echo "scale=0; obase=${base}; ibase=${base}; ${fractional_groups[${index}]} + 1" | bc`
      while [ ${#fractional_groups[${index}]} -lt ${group} ]
         do
            fractional_groups[${index}]="0${fractional_groups[${index}]}"
         done
      rounding_sign="-"
   fi

   for (( i=0; i < ${extragroups}; i++ ))
      do
         unset fractional_groups[${#fractional_groups[*]}-1]      
      done

   echo `echo "${integer}.${fractional_groups[*]}${rounding_sign}" | tr "\\n" " "`

   return;
}

declare -r -i istesting=0 # 1 if testing; 0 otherwise

declare -i base   # base
declare -i digits # number of fractional digits
declare -i group  # digits per group
declare -i length # line length
declare -i groups # number of groups

if [ ${istesting} != 0 ]; then
   base=8
   digits=45
   group=5
else
   base=16
   digits=36
   group=4
fi
length=4*${digits}+2*${group}
groups=${digits}/${group}

# constants (known)

declare -r -A constants_known=(
                ["01_0dot1"]="0.06314 63146 31463 14631 46314 63146 31463 14631 46315-"
               ["02_0dot01"]="0.00507 53412 17270 24365 60507 53412 17270 24365 60510-"
              ["03_0dot001"]="0.00040 61115 64570 65176 76355 44264 16254 02030 44672+"
             ["04_0dot0001"]="0.00003 21556 13530 70414 54512 75170 33021 15002 35223-"
            ["05_0dot00001"]="0.00000 24761 32610 70664 36041 06077 17401 56063 34417-"
           ["06_0dot000001"]="0.00000 02061 57364 05536 66151 55323 07746 44470 26033+"
          ["07_0dot0000001"]="0.00000 00153 27745 15274 53644 12741 72312 20354 02151+"
         ["08_0dot00000001"]="0.00000 00012 57143 56106 04303 47374 77341 01512 63327+"
        ["09_0dot000000001"]="0.00000 00001 04560 27640 46655 12262 71426 40124 21742+"
       ["10_0dot0000000001"]="0.00000 00000 06676 33766 35367 55653 37265 34642 01627-"
          ["11_squareroot2"]="1.32404 74631 77167 46220 42627 66115 46725 12575 17435+"
          ["12_squareroot3"]="1.56663 65641 30231 25163 54453 50265 60361 34073 42223-"
          ["13_squareroot5"]="2.17067 36334 57722 47602 57471 63003 00563 55620 32021-"
         ["14_squareroot10"]="3.12305 40726 64555 22444 02242 57101 41466 33775 22532+"
           ["15_cubicroot2"]="1.20505 05746 15345 05342 10756 65334 25574 22415 03024+"
           ["16_cubicroot3"]="1.34233 50444 22175 73134 67363 76133 05334 31147 60121-"
       ["17_quadraticroot2"]="1.14067 74050 61556 12455 72152 64430 60271 02755 73136+"
                  ["18_ln2"]="0.54271 02775 75071 73632 57117 07316 30007 71366 53640+"
                  ["19_ln3"]="1.06237 24752 55006 05227 32440 63065 25012 35574 55337+"
                 ["20_ln10"]="2.23273 06735 52524 25405 56512 66542 56026 46050 50705+"
           ["21_ln2divide1"]="1.34252 16624 53405 77027 35750 37766 40644 35175 04353+"
          ["22_ln10divide1"]="0.33626 75425 11562 41614 52325 33525 27655 14756 06220-"
                   ["23_pi"]="3.11037 55242 10264 30215 14230 63050 56006 70163 21122+"
          ["24_180dividepi"]="0.01073 72152 11224 72344 25603 54276 63351 22056 11544+"
            ["25_pidivide1"]="0.24276 30155 62344 20251 23760 47257 50765 15156 70067-"
            ["26_pisquared"]="11.67517 14467 62135 71322 25561 15466 30021 40654 34103-"
         ["27_squarerootpi"]="1.61337 61106 64736 65247 47035 40510 15273 34470 17762-"
        ["28_gamma3divide1"]="2.53347 35234 51013 61316 73106 47644 54653 00106 66046-"
        ["29_gamma3divide2"]="1.26523 57112 14154 74312 54572 37655 60126 23231 02452+"
                    ["30_e"]="2.55760 52130 50535 51246 52773 42542 00471 72363 61661+"
             ["31_edivide1"]="0.27426 53066 13167 46761 52726 75436 02440 52371 03355+"
             ["32_esquared"]="7.30714 45615 23355 33460 63507 35040 32664 25356 50217+"
                ["33_gamma"]="0.44742 14770 67666 06172 23215 74376 01002 51313 25521-"
                 ["34_lnpi"]="1.11206 40443 47503 36413 65374 52661 52410 37511 46057+"
                  ["35_phi"]="1.47433 57156 27751 23701 27634 71401 40271 66710 15010+"
          ["36_epowergamma"]="1.61772 13452 61152 65761 22477 36553 53327 17554 21260+"
      ["37_epower4dividepi"]="2.14275 31512 16162 52370 35530 11342 53525 44307 02171-"
                 ["38_sin1"]="0.65665 24436 04414 73402 03067 23644 11612 07474 14505-"
                 ["39_cos1"]="0.42450 50037 32406 42711 07022 14666 27320 70675 12321+"
   ["40_negativezetaprime2"]="0.74001 45144 53253 42362 42107 23350 50074 46100 27706+"
                ["41_zeta3"]="1.14735 00023 60014 20470 15613 42561 31715 10177 06614+"
                ["42_lnphi"]="0.36630 26256 61213 01145 13700 41004 52264 30700 40646+"
         ["43_lnphidivide1"]="2.04776 60111 17144 41512 11436 16575 00355 43630 40651+"
        ["44_negativelnln2"]="0.27351 71233 67265 63650 17401 56637 26334 31455 57005-"
)



# constants (computed)

declare -r constant_computed_28_gamma3divide1=`echo "scale=2*${digits}+${group}; obase=10;" | cat - gamma.bc | BC_LINE_LENGTH=${length} bc -l`
declare -r constant_computed_33_gamma=`echo "scale=2*${digits}+${group}; obase=10;" | cat - eulermascheroni.bc | BC_LINE_LENGTH=${length} bc -l`
declare -r constant_computed_40_negativezetaprime2=`echo "scale=2*${digits}+${group}; obase=10;" | cat - zetaderivative2.bc | BC_LINE_LENGTH=${length} bc -l`
declare -r constant_computed_41_zeta3=`echo "scale=2*${digits}+${group}; obase=10;" | cat - apery.bc | BC_LINE_LENGTH=${length} bc -l`

declare -r -A constants_computed=(
                ["01_0dot1"]=`get_constant "1.0/10.0"                                                           ${base} ${digits} ${group}`
               ["02_0dot01"]=`get_constant "1.0/100.0"                                                          ${base} ${digits} ${group}`
              ["03_0dot001"]=`get_constant "1.0/1000.0"                                                         ${base} ${digits} ${group}`
             ["04_0dot0001"]=`get_constant "1.0/10000.0"                                                        ${base} ${digits} ${group}`
            ["05_0dot00001"]=`get_constant "1.0/100000.0"                                                       ${base} ${digits} ${group}`
           ["06_0dot000001"]=`get_constant "1.0/1000000.0"                                                      ${base} ${digits} ${group}`
          ["07_0dot0000001"]=`get_constant "1.0/10000000.0"                                                     ${base} ${digits} ${group}`
         ["08_0dot00000001"]=`get_constant "1.0/100000000.0"                                                    ${base} ${digits} ${group}`
        ["09_0dot000000001"]=`get_constant "1.0/1000000000.0"                                                   ${base} ${digits} ${group}`
       ["10_0dot0000000001"]=`get_constant "1.0/10000000000.0"                                                  ${base} ${digits} ${group}`
          ["11_squareroot2"]=`get_constant "sqrt(2.0)"                                                          ${base} ${digits} ${group}`
          ["12_squareroot3"]=`get_constant "sqrt(3.0)"                                                          ${base} ${digits} ${group}`
          ["13_squareroot5"]=`get_constant "sqrt(5.0)"                                                          ${base} ${digits} ${group}`
         ["14_squareroot10"]=`get_constant "sqrt(10.0)"                                                         ${base} ${digits} ${group}`
           ["15_cubicroot2"]=`get_constant "e((1.0/3.0)*l(2.0))"                                                ${base} ${digits} ${group}` # root_n(x) = x^(1/n) = e^((1/n)*ln(x))
           ["16_cubicroot3"]=`get_constant "e((1.0/3.0)*l(3.0))"                                                ${base} ${digits} ${group}` # root_n(x) = x^(1/n) = e^((1/n)*ln(x))
       ["17_quadraticroot2"]=`get_constant "e((1.0/4.0)*l(2.0))"                                                ${base} ${digits} ${group}` # root_n(x) = x^(1/n) = e^((1/n)*ln(x))
                  ["18_ln2"]=`get_constant "l(2.0)"                                                             ${base} ${digits} ${group}`
                  ["19_ln3"]=`get_constant "l(3.0)"                                                             ${base} ${digits} ${group}`
                 ["20_ln10"]=`get_constant "l(10.0)"                                                            ${base} ${digits} ${group}`
           ["21_ln2divide1"]=`get_constant "1.0/l(2.0)"                                                         ${base} ${digits} ${group}`
          ["22_ln10divide1"]=`get_constant "1.0/l(10.0)"                                                        ${base} ${digits} ${group}`
                   ["23_pi"]=`get_constant "4.0*a(1.0)"                                                         ${base} ${digits} ${group}` # pi = 4*arctan(1)
          ["24_180dividepi"]=`get_constant "(4.0*a(1.0))/180.0"                                                 ${base} ${digits} ${group}` # pi = 4*arctan(1)
            ["25_pidivide1"]=`get_constant "1.0/(4.0*a(1.0))"                                                   ${base} ${digits} ${group}` # pi = 4*arctan(1)
            ["26_pisquared"]=`get_constant "(4.0*a(1.0))^2"                                                     ${base} ${digits} ${group}` # pi = 4*arctan(1)
         ["27_squarerootpi"]=`get_constant "sqrt(4.0*a(1.0))"                                                   ${base} ${digits} ${group}` # pi = 4*arctan(1)
        ["28_gamma3divide1"]=`get_constant "${constant_computed_28_gamma3divide1}"                              ${base} ${digits} ${group}`				              
        ["29_gamma3divide2"]=`get_constant "(2.0*4.0*a(1.0))/(sqrt(3.0)*${constant_computed_28_gamma3divide1})" ${base} ${digits} ${group}` # pi = 4*arctan(1)
                    ["30_e"]=`get_constant "e(1.0)"                                                             ${base} ${digits} ${group}`
             ["31_edivide1"]=`get_constant "1.0/e(1.0)"                                                         ${base} ${digits} ${group}`
             ["32_esquared"]=`get_constant "e(1.0)^2"                                                           ${base} ${digits} ${group}`
                ["33_gamma"]=`get_constant "${constant_computed_33_gamma}"                                      ${base} ${digits} ${group}`			              
                 ["34_lnpi"]=`get_constant "l(4.0*a(1.0))"                                                      ${base} ${digits} ${group}` # pi = 4*arctan(1)
                  ["35_phi"]=`get_constant "(1.0+sqrt(5.0))/2.0"                                                ${base} ${digits} ${group}`
          ["36_epowergamma"]=`get_constant "e(${constant_computed_33_gamma})"                                   ${base} ${digits} ${group}`
      ["37_epower4dividepi"]=`get_constant "e(a(1.0))"                                                          ${base} ${digits} ${group}` # pi/4 = arctan(1)
                 ["38_sin1"]=`get_constant "s(1.0)"                                                             ${base} ${digits} ${group}`
                 ["39_cos1"]=`get_constant "c(1.0)"                                                             ${base} ${digits} ${group}`
   ["40_negativezetaprime2"]=`get_constant "-(${constant_computed_40_negativezetaprime2})"                      ${base} ${digits} ${group}`
                ["41_zeta3"]=`get_constant "${constant_computed_41_zeta3}"                                      ${base} ${digits} ${group}`				           
                ["42_lnphi"]=`get_constant "l((1.0+sqrt(5.0))/2.0)"                                             ${base} ${digits} ${group}`
         ["43_lnphidivide1"]=`get_constant "1.0/l((1.0+sqrt(5.0))/2.0)"                                         ${base} ${digits} ${group}`
        ["44_negativelnln2"]=`get_constant "-l(l(2.0))"                                                         ${base} ${digits} ${group}`
)

# constant labels in tex format

declare -r -A constants_tex=(
                ["01_0dot1"]="0.1"
               ["02_0dot01"]="0.01"
              ["03_0dot001"]="0.001"
             ["04_0dot0001"]="0.0001"
            ["05_0dot00001"]="0.00001"
           ["06_0dot000001"]="0.000001"
          ["07_0dot0000001"]="0.0000001"
         ["08_0dot00000001"]="0.00000001"
        ["09_0dot000000001"]="0.000000001"
       ["10_0dot0000000001"]="0.0000000001"
          ["11_squareroot2"]="\\sqrt{2}"
          ["12_squareroot3"]="\\sqrt{3}"
          ["13_squareroot5"]="\\sqrt{5}"
         ["14_squareroot10"]="\\sqrt{10}"
           ["15_cubicroot2"]="\\sqrt[3]{2}"
           ["16_cubicroot3"]="\\sqrt[3]{3}"
       ["17_quadraticroot2"]="\\sqrt[4]{2}"
                  ["18_ln2"]="\\ln 2"
                  ["19_ln3"]="\\ln 3"
                 ["20_ln10"]="\\ln 10"
           ["21_ln2divide1"]="1/\\ln 2"
          ["22_ln10divide1"]="1/\\ln 10"
                   ["23_pi"]="\\pi"
          ["24_180dividepi"]="1^{\\circ} = \\pi/180"
            ["25_pidivide1"]="1/\\pi"
            ["26_pisquared"]="\\pi^2"
         ["27_squarerootpi"]="\\sqrt{\\pi} = \\Gamma(1/2)"
        ["28_gamma3divide1"]="\\Gamma(1/3)"				              
        ["29_gamma3divide2"]="\\Gamma(2/3)"
                    ["30_e"]="e"
             ["31_edivide1"]="1/e"
             ["32_esquared"]="e^2"
                ["33_gamma"]="\\gamma"		              
                 ["34_lnpi"]="\\ln \\pi"
                  ["35_phi"]="\\phi"
          ["36_epowergamma"]="e^\\gamma"
      ["37_epower4dividepi"]="e^{\\pi/4}"
                 ["38_sin1"]="\\sin 1"
                 ["39_cos1"]="\\cos 1"
   ["40_negativezetaprime2"]="-\\zeta^{\\prime}(2)"
                ["41_zeta3"]="\\zeta(3)"	           
                ["42_lnphi"]="\\ln \\phi"
         ["43_lnphidivide1"]="1/\\ln \\phi"
        ["44_negativelnln2"]="-\\ln \\ln 2"
)

declare    key               # constants (computed or known) map key
declare    constant_known    # constant (known)
declare    constant_computed # constant (computed)
declare    constant_tex      # constant (tex)
declare -i index             # general index
declare    token             # constant token

if [ ${istesting} != 0 ]; then
   for key in `echo "${!constants_known[*]}" | tr " " "\\n" | sort`
      do
         constant_known=${constants_known[${key}]}
         constant_computed=${constants_computed[${key}]}
         if [ "${constant_computed}" != "${constant_known}" ]; then
            printf "[\"${key}\"]\n${constant_known}\t# known\n${constant_computed}\t# computed\n"
         fi
      done
else

   # tex

   printf "\\\documentclass{book}\n"
   printf "\\\pagestyle{empty}\n"
   printf "\\\begin{document}\n"
   printf "\\\begin{center}\n"
   printf "\\section*{Table 2}\n"
   printf "\\\textsc{quantities that are frequently used in standard subroutines and in analysis of computer programs (36 hexadecimal places)}%c%c\n" '\' '\'
   printf "\\\\medskip\n"
   printf "\\\small{The names at the left of the %c%c$=$'' signs are given in decimal notation.}%c%c\n" '`' '`' '\' '\'
   printf "\\\\medskip\n"
   printf "\\\begin{tabular}{r@{\\\hspace{3pt}}c@{\\\hspace{3pt}}r@{.}l@{\\\hspace{3pt}}l@{\\\hspace{3pt}}l@{\\\hspace{3pt}}l@{\\\hspace{3pt}}l@{\\\hspace{3pt}}l@{\\\hspace{3pt}}l@{\\\hspace{3pt}}l@{\\\hspace{3pt}}l}\n"
   printf "\\\hline\n"

   for key in `echo "${!constants_tex[*]}" | tr " " "\\n" | sort`
      do
         constant_tex=${constants_tex[${key}]}
         constant_computed=${constants_computed[${key}]}

         printf "\$${constant_tex}\$&\$=\$&"
         index=0
         for token in `echo "${constant_computed}" | tr " " "\\n"`
            do
               if [ ${index} -eq "0" ]; then
                  printf "\$\\\mathtt{${token%%\.*}}\$&\$\\\mathtt{${token#*\.}}\$"
               elif [ ${index} -eq `expr ${groups} - 1` ]; then
                  printf "\$\\\mathtt{${token:0:${group}}}${token:(-1)}\$"
               else
                  printf "\$\\\mathtt{${token}}\$"
               fi
               index=${index}+1
               if [ ${index} -lt ${groups} ]; then
                  printf "&"
               fi
            done
         printf "%c%c\n" '\' '\'
      done

   # tex (cont'd)

   printf "\\\hline\n"
   printf "\\\end{tabular}\n"
   printf "\\\end{center}\n"
   printf "\\\end{document}\n"

fi
